print("=== AUTO TRADE BY COINS - STANDALONE OPTIMIZED + ANTI-AFK ===\n")

-- ============================================================================
--                              ANTI-AFK SYSTEM
-- ============================================================================

local AntiAFK = {
    enabled = false,
    lastActivity = 0,
    interval = 60,
    connection = nil
}

function AntiAFK.start()
    if AntiAFK.enabled then 
        print("‚ö†Ô∏è  Anti-AFK already running")
        return 
    end
    
    AntiAFK.enabled = true
    AntiAFK.lastActivity = tick()
    
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë              ANTI-AFK ACTIVATED                   ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print("")
    print(string.format("‚è±Ô∏è  Activity interval: %d seconds", AntiAFK.interval))
    print("‚úÖ Anti-AFK running in background")
    print("üíì Will prevent 20-minute idle kick")
    print("")
    
    -- Start anti-AFK loop
    task.spawn(function()
        while AntiAFK.enabled do
            wait(AntiAFK.interval)
            
            if not AntiAFK.enabled then break end
            
            -- Simulate activity (safe methods)
            pcall(function()
                local vim = game:GetService("VirtualInputManager")
                local camera = workspace.CurrentCamera
                
                -- Method 1: Minimal camera movement
                local currentCF = camera.CFrame
                camera.CFrame = currentCF * CFrame.Angles(0, math.rad(0.1), 0)
                
                -- Method 2: Space key tap (minimal impact)
                vim:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                wait(0.05)
                vim:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
                
                -- Method 3: Mouse movement (very small)
                local UserInputService = game:GetService("UserInputService")
                local mousePos = UserInputService:GetMouseLocation()
                vim:SendMouseMoveEvent(
                    mousePos.X + math.random(-1, 1), 
                    mousePos.Y + math.random(-1, 1), 
                    game
                )
            end)
            
            print(string.format("[%s] üíì Anti-AFK heartbeat", os.date("%H:%M:%S")))
            AntiAFK.lastActivity = tick()
        end
    end)
end

function AntiAFK.stop()
    AntiAFK.enabled = false
    print("[Anti-AFK] Stopped")
end

function AntiAFK.setInterval(seconds)
    if seconds and seconds >= 10 then
        AntiAFK.interval = seconds
        print(string.format("[Anti-AFK] Interval set to: %d seconds", seconds))
        return true
    end
    warn("[Anti-AFK] Interval must be at least 10 seconds")
    return false
end

-- ============================================================================
--                              INITIALIZATION
-- ============================================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

print("üîÑ Initializing modules...")

-- Get Replion
local replionModule = ReplicatedStorage.Packages._Index:FindFirstChild("ytrev_replion@2.0.0-rc.3")
if not replionModule then
    error("‚ùå Replion module not found")
end
local Replion = require(replionModule.replion)
local Data = Replion.Client:WaitReplion("Data")

-- Get Net module
local Net = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net

-- Get remotes
local TradeRemote = Net["RF/InitiateTrade"]
local FavoriteRemote = Net["RE/FavoriteItem"]
local UnequipRemote = Net["RE/UnequipItem"]

-- Get utilities
local ItemUtility = nil
local PlayerStatsUtility = nil

local success1, result1 = pcall(function()
    return require(ReplicatedStorage.Shared.ItemUtility)
end)
if success1 then
    ItemUtility = result1
    print("‚úÖ ItemUtility loaded")
else
    error("‚ùå ItemUtility not found")
end

local success2, result2 = pcall(function()
    return require(ReplicatedStorage.Shared.PlayerStatsUtility)
end)
if success2 then
    PlayerStatsUtility = result2
    print("‚úÖ PlayerStatsUtility loaded")
else
    warn("‚ö†Ô∏è PlayerStatsUtility not found - using fallback")
end

print("")

-- ============================================================================
--                              CONFIGURATION
-- ============================================================================

local CONFIG = {
    -- CHANGE THESE VALUES!
    RECEIVER_USER_ID = 9574214680,  -- User ID of receiver account
    TARGET_COINS = 50000000,        -- Target coins to send (50M)
    
    -- Trading Settings - OPTIMIZED FOR CALLBACK QUEUE
    TRADE_DELAY = 4,                -- Seconds between trades (reduced)
    RETRY_DELAY = 2,                -- Seconds before retry (fast for callback)
    MAX_RETRIES = 100,              -- Max retries per fish (HIGH for callback queue)
    TIMEOUT = 2,                    -- Timeout for trade confirmation (reduced)
    
    -- Progress Display
    SHOW_EVERY_ATTEMPT = false,     -- Show every retry attempt (false = less spam)
    SHOW_EVERY_N_RETRIES = 20,      -- Show progress every N retries
    
    -- Auto-Accept Settings (for receiver)
    AUTO_ACCEPT_ENABLED = true,     -- Enable auto-accept for receiver
    
    -- Notification Settings
    NOTIFY_YUMMU_AUTO = true,       -- Send notifications to Yummu Auto
    
    -- Anti-AFK Settings
    ANTI_AFK_ENABLED = true,        -- Enable anti-AFK system
    ANTI_AFK_INTERVAL = 60,         -- Activity every 60 seconds (safe interval)
}

local STATE = {
    isReceiver = false,
    isWorker = false,
    currentUserId = LocalPlayer.UserId,
    currentUsername = LocalPlayer.Name,
    trading = false,
    totalSent = 0,
    totalSuccess = 0,
    totalFailed = 0,
    totalRetries = 0,
    startTime = 0,
}

print(string.rep("=", 70))
print("‚öôÔ∏è  CONFIGURATION - OPTIMIZED FOR CALLBACK QUEUE + ANTI-AFK")
print(string.rep("=", 70))
print("")
print(string.format("Receiver User ID: %d", CONFIG.RECEIVER_USER_ID))
print(string.format("Target Coins: %s", tostring(CONFIG.TARGET_COINS):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")))
print(string.format("Trade Delay: %ds", CONFIG.TRADE_DELAY))
print(string.format("Retry Delay: %.1fs (FAST for callback)", CONFIG.RETRY_DELAY))
print(string.format("Max Retries: %d (HIGH for queue)", CONFIG.MAX_RETRIES))
print("")
print("üõ°Ô∏è  ANTI-AFK SETTINGS:")
print(string.format("   Enabled: %s", CONFIG.ANTI_AFK_ENABLED and "YES" or "NO"))
print(string.format("   Interval: %d seconds", CONFIG.ANTI_AFK_INTERVAL))
print("   Protection: Prevents 20-min idle kick")
print("")
print("‚ö†Ô∏è  IMPORTANT: UUID collection AFTER unfavorite")
print("   - No refresh during trading (prevents rate limit)")
print("   - 100 retries for callback queue handling")
print("   - Anti-AFK runs in background")
print("")
print(string.rep("=", 70))
print("")

-- ============================================================================
--                          UTILITY FUNCTIONS
-- ============================================================================

local function formatNumber(num)
    return tostring(num):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
end

local function itemExists(uuid)
    -- DON'T refresh inventory - just check if UUID still exists
    -- This is FAST and doesn't cause rate limit
    local items = Data:GetExpect({ "Inventory", "Items" }) or {}
    for _, item in ipairs(items) do
        if item.UUID == uuid then
            return true
        end
    end
    return false
end

local function waitForTradeComplete(uuid, timeout)
    local startTime = tick()
    while tick() - startTime < timeout do
        if not itemExists(uuid) then
            return true
        end
        wait(0.1)
    end
    return false
end

local function getSellPrice(basePrice)
    if not basePrice or basePrice <= 0 then
        return 0
    end
    
    if PlayerStatsUtility and PlayerStatsUtility.GetPlayerModifiers and PlayerStatsUtility.GetSellPrice then
        local success, result = pcall(function()
            local modifiers = PlayerStatsUtility:GetPlayerModifiers(LocalPlayer)
            return PlayerStatsUtility:GetSellPrice(basePrice, modifiers)
        end)
        
        if success and result then
            return result
        end
    end
    
    return basePrice
end

local function notifyYummyAuto(message, isCompleted)
    if not CONFIG.NOTIFY_YUMMU_AUTO then return end
    
    local status = isCompleted and "Completed-" or "Status-"
    local fullMessage = status .. message
    
    print(string.format("\nüìù Yummu Auto Notification: %s", fullMessage))
end

-- ============================================================================
--                          STEP 1: VALIDATE USER
-- ============================================================================

local function validateUser()
    print(string.rep("=", 70))
    print("üë§ USER VALIDATION")
    print(string.rep("=", 70))
    print("")
    print("Current User ID:", STATE.currentUserId)
    print("Username:", STATE.currentUsername)
    print("")
    
    if STATE.currentUserId == CONFIG.RECEIVER_USER_ID then
        STATE.isReceiver = true
        print("‚úÖ Role: RECEIVER (Auto Accept Mode)")
        print("")
        return "receiver"
    else
        STATE.isWorker = true
        print("‚úÖ Role: WORKER (Trade Mode)")
        print(string.format("   Target: User ID %d", CONFIG.RECEIVER_USER_ID))
        print(string.format("   Target Coins: %s", formatNumber(CONFIG.TARGET_COINS)))
        print("")
        return "worker"
    end
end

-- ============================================================================
--                          AUTO ACCEPT (RECEIVER)
-- ============================================================================

local function startAutoAccept()
    print(string.rep("=", 70))
    print("ü§ñ AUTO ACCEPT TRADE - ACTIVATED")
    print(string.rep("=", 70))
    print("")
    
    -- START ANTI-AFK FOR RECEIVER
    if CONFIG.ANTI_AFK_ENABLED then
        AntiAFK.setInterval(CONFIG.ANTI_AFK_INTERVAL)
        AntiAFK.start()
    end
    
    print("Waiting for trade requests...")
    print("This account will auto-accept all trades")
    print("‚ö†Ô∏è  IMPORTANT: Only 1 worker can trade at a time")
    print("   Other workers will wait in callback queue")
    print("")
    
    notifyYummyAuto("ReceiverMode-AutoAcceptActive", false)
    
    local acceptCount = 0
    
    task.spawn(function()
        while true do
            wait(0.5)
            
            pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                
                if prompt and prompt:FindFirstChild("Blackout") then
                    local blackout = prompt.Blackout
                    
                    if blackout:FindFirstChild("Options") then
                        local yesButton = blackout.Options:FindFirstChild("Yes")
                        
                        if yesButton then
                            acceptCount = acceptCount + 1
                            print(string.format("[%s] ‚úÖ Auto accepting trade #%d", 
                                os.date("%H:%M:%S"), acceptCount))
                            
                            local pos = yesButton.AbsolutePosition
                            local size = yesButton.AbsoluteSize
                            local x = pos.X + size.X / 2
                            local y = pos.Y + size.Y / 2 + 50
                            
                            game:GetService("VirtualInputManager"):SendMouseButtonEvent(x, y, 0, true, game, 1)
                            wait(0.03)
                            game:GetService("VirtualInputManager"):SendMouseButtonEvent(x, y, 0, false, game, 1)
                            
                            wait(1)
                        end
                    end
                end
            end)
        end
    end)
    
    print("‚úÖ Auto Accept is running in background")
    print("‚úÖ Anti-AFK is running in background")
    print("‚úÖ This window will stay open - just leave it running")
    print("")
end

-- ============================================================================
--                    STEP 2: UNFAVORITE ALL FISH
-- ============================================================================

local function unfavoriteAllFish()
    print(string.rep("=", 70))
    print("üíî STEP 1: UNFAVORITING ALL FISH")
    print(string.rep("=", 70))
    print("")
    
    local items = Data:GetExpect({ "Inventory", "Items" }) or {}
    local favoritedCount = 0
    local unfavoritedCount = 0
    
    for _, item in ipairs(items) do
        if item.Favorited then
            local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
            if itemData and itemData.Data and itemData.Data.Type == "Fish" then
                favoritedCount = favoritedCount + 1
            end
        end
    end
    
    if favoritedCount == 0 then
        print("‚úÖ No favorited fish found")
        print("")
        return true
    end
    
    print(string.format("Found %d favorited fish", favoritedCount))
    print("Unfavoriting...\n")
    
    for _, item in ipairs(items) do
        if item.Favorited then
            local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
            
            if itemData and itemData.Data and itemData.Data.Type == "Fish" then
                local success = pcall(function()
                    FavoriteRemote:FireServer(item.UUID)
                end)
                
                if success then
                    unfavoritedCount = unfavoritedCount + 1
                    print(string.format("   [%d/%d] Unfavorited: %s", 
                        unfavoritedCount, favoritedCount, itemData.Data.Name))
                end
                
                wait(0.05)
            end
        end
    end
    
    wait(0.5)
    
    print("")
    print(string.rep("=", 70))
    print(string.format("‚úÖ Unfavorited %d fish", unfavoritedCount))
    print(string.rep("=", 70))
    print("")
    
    return true
end

-- ============================================================================
--                    STEP 3: UNEQUIP ALL ITEMS
-- ============================================================================

local function unequipAllItems()
    print(string.rep("=", 70))
    print("üîì STEP 2: UNEQUIPPING ALL ITEMS")
    print(string.rep("=", 70))
    print("")
    
    local items = Data:GetExpect({ "Inventory", "Items" }) or {}
    local unequippedCount = 0
    
    for _, item in ipairs(items) do
        if item.Equipped then
            pcall(function()
                UnequipRemote:FireServer(item.UUID)
                unequippedCount = unequippedCount + 1
            end)
            wait(0.05)
        end
    end
    
    print(string.format("‚úÖ Unequipped %d items", unequippedCount))
    print("")
    
    return true
end

-- ============================================================================
--      STEP 4: COLLECT ALL FISH UUIDs (AFTER UNFAVORITE - ONE TIME ONLY)
-- ============================================================================

local function collectAllFishUUIDs()
    print(string.rep("=", 70))
    print("üí∞ STEP 3: COLLECTING FISH UUIDs (ONE TIME ONLY)")
    print(string.rep("=", 70))
    print("")
    print("‚ö†Ô∏è  CRITICAL: UUID Collection happens ONCE")
    print("   ‚úÖ AFTER unfavorite completed")
    print("   ‚úÖ All UUIDs stored in memory")
    print("   ‚úÖ NO refresh during trading (prevents rate limit)")
    print("")
    
    -- Get fresh inventory AFTER unfavorite is done
    local items = Data:GetExpect({ "Inventory", "Items" }) or {}
    local fishList = {}
    
    print(string.format("üì¶ Scanning inventory: %d items", #items))
    print("")
    
    local debugStats = {
        totalItems = #items,
        fishItems = 0,
        favoritedFish = 0,
        equippedFish = 0,
        tradeableFish = 0,
        nonFish = 0
    }
    
    -- Collect ALL tradeable fish UUIDs in memory
    for _, item in ipairs(items) do
        local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
        
        if itemData and itemData.Data then
            if itemData.Data.Type == "Fish" then
                debugStats.fishItems = debugStats.fishItems + 1
                
                if item.Favorited then
                    debugStats.favoritedFish = debugStats.favoritedFish + 1
                elseif item.Equipped then
                    debugStats.equippedFish = debugStats.equippedFish + 1
                else
                    debugStats.tradeableFish = debugStats.tradeableFish + 1
                    
                    local basePrice = itemData.Data.Price or 0
                    local sellPrice = getSellPrice(basePrice)
                    
                    -- Store UUID and metadata - NO MORE REFRESHES AFTER THIS
                    table.insert(fishList, {
                        UUID = item.UUID,
                        Name = itemData.Data.Name,
                        Price = sellPrice,
                        Id = item.Id
                    })
                end
            else
                debugStats.nonFish = debugStats.nonFish + 1
            end
        end
    end
    
    print("üìä Inventory Analysis:")
    print(string.format("   Total Items: %d", debugStats.totalItems))
    print(string.format("   Fish Items: %d", debugStats.fishItems))
    print(string.format("   - Favorited: %d %s", debugStats.favoritedFish, 
        debugStats.favoritedFish > 0 and "‚ö†Ô∏è  (should be 0!)" or ""))
    print(string.format("   - Equipped: %d", debugStats.equippedFish))
    print(string.format("   - Tradeable: %d ‚úÖ CACHED IN MEMORY", debugStats.tradeableFish))
    print(string.format("   Non-Fish: %d", debugStats.nonFish))
    print("")
    
    -- Sort by price (highest first)
    table.sort(fishList, function(a, b)
        return a.Price > b.Price
    end)
    
    print(string.rep("=", 70))
    print(string.format("‚úÖ COLLECTED %d FISH UUIDs", #fishList))
    print(string.rep("=", 70))
    print("")
    print("‚ö†Ô∏è  From this point: NO MORE INVENTORY REFRESH")
    print("   - All UUIDs are in memory")
    print("   - Trading will use cached UUIDs")
    print("   - This prevents rate limit issues")
    print("")
    
    if #fishList > 0 then
        print("Top 10 most expensive fish (with UUIDs):")
        for i = 1, math.min(10, #fishList) do
            local fish = fishList[i]
            print(string.format("   %2d. %-30s %10s coins [%s]", 
                i, fish.Name, formatNumber(fish.Price), fish.UUID:sub(1, 12) .. "..."))
        end
    else
        print("‚ö†Ô∏è  No tradeable fish found!")
        if debugStats.favoritedFish > 0 then
            print(string.format("   Problem: %d fish still favorited!", debugStats.favoritedFish))
            print("   Solution: Unfavorite step may have failed - try manual unfavorite")
        end
        if debugStats.equippedFish > 0 then
            print(string.format("   Problem: %d fish still equipped!", debugStats.equippedFish))
            print("   Solution: Unequip step may have failed - try manual unequip")
        end
    end
    
    print("")
    
    local totalValue = 0
    for _, fish in ipairs(fishList) do
        totalValue = totalValue + fish.Price
    end
    
    print(string.format("Total cached value: %s coins", formatNumber(totalValue)))
    print("")
    
    return fishList, totalValue
end

-- ============================================================================
--                    STEP 5: SELECT FISH FOR TARGET
-- ============================================================================

local function selectFishForTarget(fishList, targetCoins)
    print(string.rep("=", 70))
    print("üéØ STEP 4: SELECTING FISH FOR TARGET")
    print(string.rep("=", 70))
    print("")
    
    print(string.format("Target: %s coins", formatNumber(targetCoins)))
    print("")
    
    local selected = {}
    local totalValue = 0
    
    for _, fish in ipairs(fishList) do
        if totalValue >= targetCoins then
            break
        end
        
        table.insert(selected, fish)
        totalValue = totalValue + fish.Price
    end
    
    print(string.format("Selected %d fish (from %d cached)", #selected, #fishList))
    print(string.format("Total value: %s coins", formatNumber(totalValue)))
    
    if totalValue < targetCoins then
        print(string.format("‚ö†Ô∏è  Warning: Only %.1f%% of target", (totalValue/targetCoins)*100))
    else
        print(string.format("‚úÖ Reached %.1f%% of target", (totalValue/targetCoins)*100))
    end
    
    print("")
    
    return selected, totalValue
end

-- ============================================================================
--            STEP 6: TRADE FISH (100 RETRIES FOR CALLBACK QUEUE)
-- ============================================================================

local function tradeSingleFish(userId, fish, index, total)
    local retries = 0
    local lastError = nil
    local callbackQueue = false
    
    while retries <= CONFIG.MAX_RETRIES do
        local attempt = retries + 1
        
        -- Show progress intelligently
        local shouldShow = false
        if CONFIG.SHOW_EVERY_ATTEMPT then
            shouldShow = true
        elseif attempt == 1 or attempt == CONFIG.MAX_RETRIES + 1 then
            shouldShow = true
        elseif callbackQueue and attempt % CONFIG.SHOW_EVERY_N_RETRIES == 0 then
            shouldShow = true
        end
        
        if shouldShow then
            local queueInfo = callbackQueue and " [IN QUEUE]" or ""
            print(string.format("[%d/%d] %s (%s coins) - Attempt %d/%d%s", 
                index, total, fish.Name, formatNumber(fish.Price), 
                attempt, CONFIG.MAX_RETRIES + 1, queueInfo))
        end
        
        local success, result = pcall(function()
            return TradeRemote:InvokeServer(userId, fish.UUID)
        end)
        
        if not success then
            lastError = tostring(result)
            
            -- Detect callback/queue errors
            if lastError:find("callback") or lastError:find("queue") or 
               lastError:find("busy") or lastError:find("wait") then
                if not callbackQueue then
                    callbackQueue = true
                    print("        ‚è≥ Receiver busy - entering callback queue...")
                    print("           (Will retry up to 100 times)")
                end
                STATE.totalRetries = STATE.totalRetries + 1
            else
                -- Other error
                if shouldShow then
                    print(string.format("        ‚ùå ERROR: %s", lastError:sub(1, 50)))
                end
            end
            
            retries = retries + 1
            if retries <= CONFIG.MAX_RETRIES then
                wait(CONFIG.RETRY_DELAY)
            end
            
        elseif result == true then
            -- Trade initiated successfully
            if shouldShow or callbackQueue then
                print("        ‚è≥ Trade accepted, confirming...")
            end
            
            local confirmed = waitForTradeComplete(fish.UUID, CONFIG.TIMEOUT)
            
            if confirmed then
                if callbackQueue then
                    print(string.format("        ‚úÖ SUCCESS (after %d queue retries)", retries))
                else
                    print("        ‚úÖ SUCCESS")
                end
                STATE.totalSent = STATE.totalSent + fish.Price
                STATE.totalSuccess = STATE.totalSuccess + 1
                return true
            else
                -- Double-check if item is actually gone
                if not itemExists(fish.UUID) then
                    print("        ‚úÖ SUCCESS (confirmed via inventory)")
                    STATE.totalSent = STATE.totalSent + fish.Price
                    STATE.totalSuccess = STATE.totalSuccess + 1
                    return true
                else
                    -- Timeout but item still exists, retry
                    if shouldShow then
                        print("        ‚è≥ Timeout, retrying...")
                    end
                    retries = retries + 1
                    if retries <= CONFIG.MAX_RETRIES then
                        wait(CONFIG.RETRY_DELAY)
                    end
                end
            end
            
        else
            -- Server returned false
            if shouldShow then
                print("        ‚ùå Trade rejected by server")
            end
            retries = retries + 1
            if retries <= CONFIG.MAX_RETRIES then
                wait(CONFIG.RETRY_DELAY)
            end
        end
    end
    
    -- Failed after all retries
    print(string.format("        ‚ùå FAILED after %d attempts", CONFIG.MAX_RETRIES + 1))
    if lastError then
        print(string.format("        Last error: %s", lastError:sub(1, 100)))
    end
    STATE.totalFailed = STATE.totalFailed + 1
    return false
end

local function tradeAllFish(selectedFish)
    print(string.rep("=", 70))
    print("üöÄ STEP 5: TRADING (WITH CALLBACK QUEUE HANDLING)")
    print(string.rep("=", 70))
    print("")
    print(string.format("Total fish to trade: %d", #selectedFish))
    print(string.format("Delay per trade: %ds", CONFIG.TRADE_DELAY))
    print(string.format("Max retries per fish: %d (for callback queue)", CONFIG.MAX_RETRIES))
    print(string.format("Estimated minimum time: ~%d minutes", 
        math.ceil((#selectedFish * CONFIG.TRADE_DELAY) / 60)))
    print("")
    print("‚ö†Ô∏è  IMPORTANT:")
    print("   - All UUIDs already cached (no refresh)")
    print("   - High retry count handles callback queue")
    print("   - If receiver busy, worker waits in queue")
    print("   - Anti-AFK running in background")
    print("")
    
    notifyYummyAuto(string.format("TradingStarted-%dfish", #selectedFish), false)
    
    STATE.trading = true
    STATE.totalSent = 0
    STATE.totalSuccess = 0
    STATE.totalFailed = 0
    STATE.totalRetries = 0
    STATE.startTime = tick()
    
    for i, fish in ipairs(selectedFish) do
        if not STATE.trading then
            print("\n‚ö†Ô∏è Trade stopped by user")
            notifyYummyAuto("TradeStopped-ByUser", true)
            break
        end
        
        tradeSingleFish(CONFIG.RECEIVER_USER_ID, fish, i, #selectedFish)
        
        -- Show progress every 10 trades
        if i % 10 == 0 or i == #selectedFish then
            print("")
            print(string.rep("-", 70))
            print(string.format("üìä Progress: %d/%d (%.1f%%)", i, #selectedFish, (i/#selectedFish)*100))
            print(string.format("üí∞ Sent: %s / %s coins (%.1f%%)", 
                formatNumber(STATE.totalSent), formatNumber(CONFIG.TARGET_COINS),
                (STATE.totalSent/CONFIG.TARGET_COINS)*100))
            print(string.format("‚úÖ Success: %d | ‚ùå Failed: %d | ‚è≥ Total Retries: %d", 
                STATE.totalSuccess, STATE.totalFailed, STATE.totalRetries))
            local elapsed = math.floor(tick() - STATE.startTime)
            local remaining = math.ceil((elapsed / i) * (#selectedFish - i))
            print(string.format("‚è±Ô∏è  Elapsed: %dm %ds | Remaining: ~%dm %ds", 
                math.floor(elapsed/60), elapsed%60,
                math.floor(remaining/60), remaining%60))
            print(string.format("üíì Anti-AFK: %s", AntiAFK.enabled and "ACTIVE" or "INACTIVE"))
            print(string.rep("-", 70))
            print("")
            
            notifyYummyAuto(string.format("Progress-%d%%-%scoins", 
                math.floor((i/#selectedFish)*100), formatNumber(STATE.totalSent)), false)
        end
        
        -- Wait between trades
        if i < #selectedFish then
            wait(CONFIG.TRADE_DELAY)
        end
    end
    
    local duration = math.floor(tick() - STATE.startTime)
    local minutes = math.floor(duration / 60)
    local seconds = duration % 60
    
    STATE.trading = false
    
    return duration, minutes, seconds
end

-- ============================================================================
--                    STEP 7: CHECK INVENTORY
-- ============================================================================

local function checkInventoryEmpty()
    print(string.rep("=", 70))
    print("üì¶ CHECKING INVENTORY STATUS")
    print(string.rep("=", 70))
    print("")
    
    local items = Data:GetExpect({ "Inventory", "Items" }) or {}
    local fishCount = 0
    
    for _, item in ipairs(items) do
        local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
        if itemData and itemData.Data and itemData.Data.Type == "Fish" then
            fishCount = fishCount + 1
        end
    end
    
    if fishCount == 0 then
        print("‚úÖ INVENTORY IS EMPTY - All fish traded!")
        print("")
        return true
    else
        print(string.format("‚ö†Ô∏è  Remaining fish: %d", fishCount))
        print("")
        return false
    end
end

-- ============================================================================
--                    FINAL SUMMARY
-- ============================================================================

local function showFinalSummary(duration, minutes, seconds)
    print(string.rep("=", 70))
    print("üéâ TRADE COMPLETED")
    print(string.rep("=", 70))
    print("")
    print("üìä Statistics:")
    print(string.format("   ‚úÖ Success:      %d", STATE.totalSuccess))
    print(string.format("   ‚ùå Failed:       %d", STATE.totalFailed))
    print(string.format("   üì¶ Total:        %d", STATE.totalSuccess + STATE.totalFailed))
    print(string.format("   üîÑ Total Retries: %d (callback queue handling)", STATE.totalRetries))
    print("")
    print(string.format("üí∞ Coins Sent:      %s", formatNumber(STATE.totalSent)))
    print(string.format("üéØ Target:          %s", formatNumber(CONFIG.TARGET_COINS)))
    print(string.format("üìà Achievement:     %.1f%%", (STATE.totalSent/CONFIG.TARGET_COINS)*100))
    print("")
    print(string.format("‚è±Ô∏è  Duration:        %dm %ds", minutes, seconds))
    if STATE.totalSuccess > 0 then
        print(string.format("‚è±Ô∏è  Avg per fish:    %.1fs", duration / STATE.totalSuccess))
    end
    if STATE.totalRetries > 0 then
        print(string.format("üìä Avg retries:     %.1f per fish", STATE.totalRetries / (STATE.totalSuccess + STATE.totalFailed)))
    end
    print(string.format("üíì Anti-AFK Status: %s", AntiAFK.enabled and "ACTIVE" or "STOPPED"))
    print(string.rep("=", 70))
    print("")
    
    local isEmpty = checkInventoryEmpty()
    
    if isEmpty then
        print("‚úÖ All items traded successfully!")
        notifyYummyAuto(string.format("TradeCompleted-%scoins", formatNumber(STATE.totalSent)), true)
        
        print("\n‚úÖ DONE! Next steps:")
        print("   1. Switch to next bot manually (Yummu Auto)")
        print("   2. Or check receiver account for items")
        print("   3. Run script again on another worker")
    else
        print("‚ö†Ô∏è  Some items remain in inventory")
        print("   (May be favorited or failed trades)")
        notifyYummyAuto(string.format("TradePartial-%scoins", formatNumber(STATE.totalSent)), true)
    end
    
    print("")
end

-- ============================================================================
--                          MAIN WORKFLOW
-- ============================================================================

local function startWorkerMode()
    print(string.rep("=", 70))
    print("ü§ñ WORKER MODE - OPTIMIZED FOR CALLBACK QUEUE + ANTI-AFK")
    print(string.rep("=", 70))
    print("")
    
    notifyYummyAuto("WorkerMode-Starting", false)
    
    -- START ANTI-AFK FIRST
    if CONFIG.ANTI_AFK_ENABLED then
        AntiAFK.setInterval(CONFIG.ANTI_AFK_INTERVAL)
        AntiAFK.start()
    end
    
    -- STEP 1: Unfavorite all fish
    local step1 = unfavoriteAllFish()
    if not step1 then
        print("‚ùå Failed at Step 1")
        notifyYummyAuto("Failed-UnfavoriteFish", true)
        AntiAFK.stop()
        return
    end
    
    -- STEP 2: Unequip all items
    local step2 = unequipAllItems()
    if not step2 then
        print("‚ùå Failed at Step 2")
        notifyYummyAuto("Failed-UnequipItems", true)
        AntiAFK.stop()
        return
    end
    
    wait(1)
    
    -- STEP 3: Collect ALL fish UUIDs (AFTER unfavorite - ONE TIME ONLY)
    local fishList, totalValue = collectAllFishUUIDs()
    
    if #fishList == 0 then
        print("‚ùå No tradeable fish found!")
        print("\nüí° Possible issues:")
        print("   - Fish still favorited (check Step 1)")
        print("   - Fish still equipped (check Step 2)")
        print("   - No fish in inventory")
        print("")
        notifyYummyAuto("NoFishFound-Skipping", true)
        AntiAFK.stop()
        return
    end
    
    -- STEP 4: Select fish for target
    local selectedFish, selectedValue = selectFishForTarget(fishList, CONFIG.TARGET_COINS)
    
    if #selectedFish == 0 then
        print("‚ùå No fish selected!")
        notifyYummyAuto("NoFishSelected-Skipping", true)
        AntiAFK.stop()
        return
    end
    
    print("‚è∏Ô∏è  Ready to start trading")
    print(string.format("   Fish to trade: %d", #selectedFish))
    print(string.format("   Total value: %s coins", formatNumber(selectedValue)))
    print(string.format("   To receiver: User ID %d", CONFIG.RECEIVER_USER_ID))
    print(string.format("   Anti-AFK: %s", CONFIG.ANTI_AFK_ENABLED and "ENABLED" or "DISABLED"))
    print("")
    print("Starting in 3 seconds...")
    print("üí° To stop: Call StopAutoTrade() in console")
    print("")
    
    notifyYummyAuto(string.format("PreparingTrade-%dfish-%scoins", 
        #selectedFish, formatNumber(selectedValue)), false)
    
    wait(3)
    
    -- STEP 5: Trade all fish (using cached UUIDs)
    local duration, minutes, seconds = tradeAllFish(selectedFish)
    
    showFinalSummary(duration, minutes, seconds)
    
    -- Stop Anti-AFK after trading completes
    print("\nüõ°Ô∏è  Stopping Anti-AFK...")
    AntiAFK.stop()
end

-- ============================================================================
--                          START SCRIPT
-- ============================================================================

print(string.rep("=", 70))
print("üöÄ AUTO TRADE BY COINS - STANDALONE OPTIMIZED + ANTI-AFK")
print(string.rep("=", 70))
print("")
print("‚ÑπÔ∏è  This version is OPTIMIZED for:")
print("   ‚úÖ No rate limit (UUID collection once)")
print("   ‚úÖ Callback queue handling (100 retries)")
print("   ‚úÖ Multiple workers ‚Üí single receiver")
print("   ‚úÖ Pure local operation (no HTTP)")
print("   ‚úÖ Anti-AFK protection (prevents 20-min kick)")
print("")
print(string.rep("=", 70))
print("")

local userRole = validateUser()

if userRole == "receiver" then
    if CONFIG.AUTO_ACCEPT_ENABLED then
        startAutoAccept()
    else
        print("‚ÑπÔ∏è  Auto-accept is disabled in config")
        print("   You'll need to accept trades manually")
        print("")
        
        -- Still start anti-AFK for receiver
        if CONFIG.ANTI_AFK_ENABLED then
            AntiAFK.setInterval(CONFIG.ANTI_AFK_INTERVAL)
            AntiAFK.start()
        end
    end
elseif userRole == "worker" then
    startWorkerMode()
end

-- Stop function
getgenv().StopAutoTrade = function()
    STATE.trading = false
    AntiAFK.stop()
    notifyYummyAuto("StoppedByUser", true)
    print("\nüõë Auto trade stopped")
    print("üõ°Ô∏è  Anti-AFK stopped")
    print("")
end

print("üí° Commands:")
print("   StopAutoTrade() - Stop trading and anti-AFK immediately")
print("")
print("üõ°Ô∏è  Anti-AFK Features:")
print("   - Automatic activity every 60 seconds")
print("   - Prevents 20-minute idle kick")
print("   - Camera movement + keyboard input")
print("   - Runs in background during trading")
print("")
